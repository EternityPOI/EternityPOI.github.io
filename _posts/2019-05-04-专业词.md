---
layout: post
title: Professional Words
description: null
image: null
---

---diff
 + **纯函数**
1. 纯函数不会以任何方式修改状态或者类的成员
2. 纯函数一般用于getter函数或者仅输出一个数据值
3. 纯函数连接到数据引脚上，当需要依赖于纯函数的数据时，编译器自动执行函数，意味着对于每个连接到纯函数上的节点，都会调用一次纯函数
    - 在代码中定义的函数声明中指定`Blueprint Pure`
    - 将蓝图编辑器添加的函数的`Detail`面板中`Pure`复选框勾选


 - **非纯函数**
1. 非纯函数可以自由的修改状态
2. 非纯函数必须通过在事件图表中将执行线连接到函数调用节点来显示的执行，非纯函数通过以下方式指定
    - 在代码定义的函数声明中指定`Blueprint Callable`
    - 将蓝图编辑器添加的函数的`Detail`面板中`Pure`复选框取消勾选 
---

- 构造脚本：创建类蓝图时，Construction Script在Component列表之后运行，构造脚本包含一个节点图表，执行该图表使该蓝图实例执行初始化操作。该功能强大，像在世界中执行追踪、设置网格物体和材质这样的动作可以用于实现情景关联的设置。如：一个光源蓝图可以决定它所放置到的地面类型，且可以从一组网格物体中选择要使用的正确的网格物体，或者一个篱笆蓝图，它可以在各个方向上追踪，来决定篱笆需要多长才能跨越那个距离

- UObject: 是所有类的基类，实现了诸如垃圾回收、开放变量给编辑器的元数据（UProperty），以及存盘和读盘时的序列化功能

- Actor: 是可以放置在关卡中的任意对象。Actor 是支持三维变换的通用类，比如如平移，旋转和缩放变换。 Actor 可以通过游戏代码（C++或蓝图）来创建（Spawn）及销毁。在 C++ 中，AActor 是所有 Actor 的基类

- 组件 是一种特殊类型的对象，用作为 Actor 中的一个子对象。组件一般用于需要简单地切换的部件的地方，以便改变具有该组件的 Actor 的某个特定方面的行为或功能。比如，一辆汽车的控制机及运动和飞机是有很大差别的，而飞机的控制和运动又和船有很大区别，以此类推；然而，所有这些都是交通工具，它们存在一些共性。通过使用一个组件来处理这些控制及运动，可以很轻松地使得同一交通工具的行为变得像任何一种特定类型的交通工具

- Pawn 是Actor的子类，可作为游戏中的化身或人物，例如游戏中的角色。 Pawn可以由玩家控制或由游戏的AI控制，比如非玩家控制角色(NPCs)。当Pawn由人类玩家或AI玩家控制，它被视为Possessed。 相反地，当Pawn不由人类玩家或AI玩家控制，它被视为UnPossessed

- Character（角色） 是Pawn Actor的子类，用作为玩家角色。Character相对于Pawn最大的区别是增加了一个CharacterMovement的组件，支持骨架网格物体，并包括碰撞设置、两足动物运动的输入绑定、及由玩家控制的运动的额外代码

- PlayerController类被用于获得玩家输入并将其转化为游戏中的互动，并且每个游戏至少有1个玩家控制器。 PlayerController（玩家控制器）常常支配着游戏中代表玩家的Pawn或角色.PlayerController（玩家控制器）也是多人游戏中的主要网络交互点。 在多人游戏中，服务器具有游戏中每个玩家的玩家控制器的一个实例，因为它必须能对每个玩家进行网络函数调用。每个客户端仅具有与其玩家相符的玩家控制器，并且仅能使用其玩家控制器来与服务器沟通

- 正如 PlayerController 控制一个 Pawn 让其代表游戏中的玩家一样，AIController 则控制一个 Pawn 让其代表游戏中的非玩家角色（NPC）。 默认情况下，Pawn 和 Character 都将由 AIController 这个基类控制，或者人为为它们指定一个 PlayerController 控制，又或者为其自身创建一个特定的 AIController 子类

- brush （画刷）是用来定义BSP关卡几何体和游戏体积的3D体积。 另外，它也表示您可以用来对表面或场景涂画不同的值（比如颜色）的一种用户接口设备。画刷通常用来创建关卡原型

- level 就是游戏地图,在虚幻编辑器中，每个关卡都被保存为单独的.umap文件，它与项目文件 (.uproject)不同

- GameMode 类负责设置正在运行的游戏的规则。这些规则包括了玩家如何加入游戏、游戏是否可以暂停、关卡转变及任何游戏特定行为，如胜利条件等。
您可以在 Project Settings（项目设置） 中设置默认游戏模式，但您可以基于每个关卡覆盖该设置。无论您选择如何实现游戏模式，每个关卡中将总是仅存在一种游戏模式。在多玩家游戏中，游戏模式仅存在于服务器上，各种规则会被复制（发送）到每个连接的客户端上

- GameState（游戏状态） 包含了在游戏中您想复制到每个客户端的信息，或者更简单地讲，它就是每个连接到该游戏的人的“游戏状态”。
它通常包括的信息有游戏分数、比赛是否开始、根据世界中玩家数量要生成多少个AI及其他游戏相关的信息。
对于多玩家游戏，每个玩家的机器上都有一个GameState的实例，其中服务器的实例（或者客户端从其获取更新的实例）是最权威的

- PlayerState 是游戏中的一个参与者的状态，比如人类玩家或者模拟人类玩家的机器人。 
PlayerState（玩家状态）中出现的恰当的示例数据包括玩家名称或分数、其当前关卡或生命值、或者其当前是否在Capture the Flag（夺旗）游戏中携带旗帜。
对多人游戏来说，所有玩家的玩家状态存在于所有电脑上（这点和PlayerController玩家控制器不同），并且可以从服务器复制数据到客户端以保持其同步

---

- Textures (贴图）是在材质中使用的图像。 它们被映射到应用材质的表面。 贴图要么被直接应用-比如说，基础颜色贴图-要么贴图的像素（或用英语略写为 texels ）值被作为蒙板或其它计算方法在材质中使用。 在一些实例中，在材质外部也可以直接使用贴图，例如绘制到 HUD。 大多数情况下，贴图是在如 Photoshop 这样的图像编辑应用的外部程序中进行创建的，然后通过内容浏览器导入到虚幻编辑器中。 然而，一些贴图是在虚幻中生成的，例如渲染贴图。 通常情况下，它们会从场景中选取一些信息，然后将其渲染为可在其他地方使用的贴图。
一个单一材质有可能用到几个不同的纹理贴图作为不同的目的效果。比如，一个简单的材质可能会有一个基础颜色的纹理贴图，一个高光纹理，一个法线贴图。除此以外，还有可能有保存在透明通道中的自发光贴图以及粗造度贴图.可以发现，虽然这些可能都同时存在于一个贴图的布局中，但纹理贴图中的不同的颜色被用于不同的目的

- 材质 是可以应用到网格物体上的资源，用它可控制场景的可视外观。从较高的层面上来说，可能最简单的方法就是把材质视为应用到一个物体的"描画"。但这种说法也会产生一点点误导，因为材质实际上定义了组成该物体所用的表面类型。您可以定义它的颜色、它的光泽度及您是否能看穿该物体等等。
用更为专业的术语来说，当穿过场景的光照接触到表面后，材质被用来计算该光照如何与该表面进行互动。这些计算是通过对材质的输入数据来完成的，而这些输入数据来自于一系列图像（贴图）以及数学表达式，以及材质本身所继承的不同属性设置。
虚幻引擎 4 使用了基于物理的着色器模型（就是PBR材质）。这意味着不再使用数学模型中的某个参数属性（比如漫反射颜色和高光次幂）定义一个材质，而是使用和现实世界更加相关的属性定义材质。这些属性包括底色、金属色、高光及粗糙度

- 
