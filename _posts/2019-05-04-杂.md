---
layout: post
title: Miscellaneous
description: null
image: null
---

- 修改场景初始目录：主菜单 编辑->项目设置->地图和模式

- 虚幻中 1单位=1cm,2英尺=61单位，左手坐标系

- 如何抛出异常：虚幻4并不处理异常，而是用Check()来触发严重的错误，可以传入一个错误信息提示。如果只想报告，不想打断，用ensure(),这会记录完整堆栈日志信息，如果当前附加了调试器，那么两个函数都会暂定并进入调试器

- 启动时载入地图：地图在游戏项目的Config目录下的`DefaultEngine.ini`中定义，默认运行的地图是通过`.ini`文件的`[URL]`部分的Map属性来设置的，一般来说，应指定载入的地图，或默认Map来作为主菜单的背景所用图

- Matinee可用来创建过场，动态游戏事件表现，基于时间改变一些角色参数(如用该工具驱动光照的基于时间的明暗变化)

- 给一个Actor添加widget后，若所添加的widget中有`CanvasPanol`则只能在该蓝图中控制大小。若无，可在widget组件上的`Draw Size`控制大小

- 设置游戏输入模式和UI关系节点 Set Input Mode Game And UI 在GameMode脚本的事件图表见一次

- isValid通常和Cast to 配合使用

- UMG中的裁剪系统使用 Slate 裁剪系统NEW! 作为框架来控制为控件（或编辑器的其他部分） 显示文本、图像或内容的方式

- 画布（Canvas） 面板（又称裁剪区）的轮廓为蓝色，代表游戏屏幕，它将会裁剪（即不绘制）游戏超出该区域的任何内容

- 在大部分情况下，都无需调整裁剪方法，除非你因无法控制文本的长度而需要裁剪它。
例如，滚动框和可编辑文本控件就符合这种情况，它们被设置为 裁剪至边界（Clip to Bounds） 而非“继承（Inherit）”
不同裁剪空间中的元素无法一起进行批处理，因此裁剪会带来性能成本。因此，
除非面板真的需要阻止内容在其边界之外显示，否则请勿启用裁剪

- 创建的简单 UI 画面包含少量变化频率较高的变量时，则需要考虑使用 属性绑定 来驱动这些变更。然而，
如果 UI 画面更为复杂，数个属性将在特定时间发生变更，则使用 基于事件的 逻辑执行这些变更为佳，
而无需在每帧进行检查确认是否应该形成变更

- 在 UMG 中创建内容时，尝试以 DPI 缩放 1.0 进行创建
这不但能确保创建的内容大小一致，将统一的比例应用到所有控件蓝图时还更便于缩放到更大/更小的屏幕尺寸

- 带有边框的图片，应用时DrawAs通常设置为Border

- 制作 UI 画面时可进行以下优化：
    - 尽量为美术资源使用 纹理，尽量不使用 材质。
    - 尽量使用 事件驱动 UI 更新，尽量不使用绑定或 Tick 事件。
    - 使用 失效框 缓存不常变化的控件。
    - 使用 控件反射器（Ctrl+Shift+W）获取关于控件的信息和数据。

-  可聚焦 选项指定按钮是否仅可以使用鼠标点击，不可用键盘选择

- 字体 是一类可以和 Text Actor 一起使用的资源（尤其是和 UMG UI Designer 一起使用），在用户界面上增加更多的元素

- 要改变布局，通常要得到控件的slot，再投射到正确的槽类型，然后从返回变量中用对应方法

- 可见（Visible） - 该控件可见，并可以与光标互动。
    - 折叠（Collapsed） - 控件不可见，并在布局中不占据空间。永远不能单击，因为它不占据空间。
    - 隐藏（Hidden） - 控件不可见，但占据布局空间。不能互动，因为是隐藏的。
    - 命中测试不可见（Hit Test Invisible） - 控件对于用户可见，但仅显示为图片。光标命中测试永远不会看到这件
    - 自命中测试不可见（Self Hit Test Invisible） - 该控件与命中测试不可见（Hit Test Invisible）一样，但不适用于子控件

- 构造脚本是蓝图类中的一类图表，在编辑器中放置或更新Actor时该蓝图类将执行（不会在游戏进程中执行）
利用此脚本可十分容易地创建可自定义的预设
自动更新材质来匹配自身点光源组件颜色与亮度的光照设备；或是将植物网格体在区域中随机散射的蓝图
在内容范例地图中，包含所有例子（以上图标所示）的长形房间实际上是由多个组件组合而成的单个蓝图。
蓝图的构造脚本会根据蓝图 细节 面板中公开的参数创建不同静态网格体和光源。创建内容范例地图后，
可进入演示房间蓝图中，设置长度、高度和生成的房间数（以及另一些选项），片刻后便能创建出完整的房间组合

- 可设置HUD来读取其他蓝图中的变量，并将读取的变量用于显示体力条、更新分数、显示任务标志等。
HUD还可用于添加元素的命中框，如可以点击的按钮；在移动平台游戏中，则用于响应触摸输入

- 发生碰撞条件：
    - Actor 之间的碰撞响应必须允许重叠。
    - 执行事件的两个 Actor 的 Generate Overlap Events 均设为 true

- 程序员可在 C++ 中创建定义自定义事件的角色类，之后蓝图可用于该角色类的延展，
实际指定模型并进行默认设置。查看 ShooterGame 范例项目中的玩家角色和敌方机器人，了解类似实现。

- 可在 C++ 中实现能力系统的基础类，之后设计师再创建实际执行操作的蓝图。
在 StrategyGame 范例项目中有一个在 C++ 中定义的基础炮台， 但火焰喷射器、火炮台和弓箭台的行为均在蓝图中定义。

- “收集”或“重生”函数为可在蓝图中实现的事件，这样的可拾取道具可被覆写，以便设计师生成不同粒子发射器和声效。
ShooterGame 和 StrategyGame 中均有此方式创建的可拾取道具。

- SetActorLocation**是增加 Pawn 派生类的运动的最佳方式。用**SetActorLocation**，你可以决定要时空转移至或迅速前往某个位置。 
迅速前往时，你的 Pawn 会沿某个方向移动，如果撞到东西就会停下来

- 如果蓝图在每个 tick 都执行大量操作和复杂的数学计算，则需要考虑使用本地 C++ 代码。
蓝图最适合创建事件驱动的功能，如处理伤害接收、控制，或其他非每帧调用的操作

- 关卡蓝图非常利于对关卡限定的功能，或其中的 Actor 进行设置。在一些范例中，触碰到特定开关时将启动过场，或在消灭所有敌人后打开一扇特定的门

- 变量设为Private后，在其他蓝图即使用定义该变量的实例来使用也不可（同时子类不继承该变量）

- 让Actor能触发鼠标点击事件
    1. 打开Controller在Mouse Interface设置相应项
    2. 在World Setting中设置游戏模式，添加改变的Controller
    3. 在Actor中添加点击事件

- 可以用蓝图或C++创建组件(在添加组件下拉中)

- 除断点外，另一个实用调试功能是 Watch Values，它可将蓝图中一个（或多个）变量标记到 观察（Watch），以便在游戏运行时在蓝图中看到变量数值。这对调试变量错误计算或数值十分重要，因为可以在变量实时变化时发现错误的源头

- 按键事件仅在按下或松开的时候触发，而轴事件时刻都触发？

- 对于输入事件，通常不在蓝图中直接增加，而是增加一个自定义输入事件，然后将这个自定义事件和输入事件绑定。这样做可以使得输入使用和维护更加直观方便，而且一个自定义事件以绑定多个设备和多个输入事件，这就是输入映射。
在项目设置-引擎-输入界面可以设置输入映射

- 按键映射:映射离散的按钮或按键到 "friendly name" （友好名称），该值稍后将会被绑定到由事件驱动的行为。 最终效果是在按下（和/或放开）一个键，鼠标按键或小键盘按键后，直接触发一些游戏行为

- 轴映射:映射键盘，控制器，或鼠标到"friendly name" （友好名称）中，该值稍后会被绑定到持续的游戏行为中，例如移动。在AxisMapping中映射的输入被持续地查看，即使它们仅仅是报告其当前输入值为零。 这使得移动或其它游戏行为非常地平滑，而不是在ActionMapping中由输入所触发的离散游戏事件。
硬件轴，例如摇杆控制器，提供输入的不同程度的反馈，而不是离散的1（已按下）或0（未按下）输入。 这表明，这些值可以变小或变大，而您角色的移动也将相应变化。 这些输入方式对提供更多类型移动的输入很有用，AxisMapping还能映射通用的移动键值，例如WASD或上，下，左，右，以及被持续观察的游戏行为

- 启用或禁用输入:在某些蓝图中，输入事件被默认启用，如关卡蓝图，但是在其他蓝图中，输入事件有可能被禁用，此时对象接收不到输入事件。这时可以使用EnableInput节点(要player controller)来启用输入

- 力反馈（Force Feedback） 指的是游戏设备或控制器通过震动将游戏中的力传达给玩家。举一个简单的例子：游戏中发生爆炸，力反馈用于模拟冲击波，形成另一个层面的代入感。
应用之后即可在支持的所有平台上实现力反馈。支持平台包括 iOS（从 4.10 起）、安卓，以及各种控制器
>   1. 创建力反馈效果资源:
    在 内容浏览器 中点击 Add New 并选择 Miscellaneous > Force Feedback Effect。资源默认包含一个通道，但可进行添加。选择力反馈效果影响设备的左侧和/或右侧，以及每侧的强弱。长按 Shift 并在曲线上点击 鼠标左键 添加一个或多个键,直接输入键的值，或将键拖入曲线编辑器中进行操作。
    和其他曲线编辑器不同的是，此处的键只能以直线连接
    2. 使用力反馈
    力反馈在基础 PlayerController 类中实现。需要访问本地 Player Controller，以便在目标设备或控制器上播放力反馈。
    通过 Get Player Controller 节点或保存的引用为玩家控制器设置一个引用,从引用的输出引脚引出连线，然后在快捷菜单中输入 Play Force Feedback，然后选择 Client Play Force Feedback,如在服务器上调用，力反馈将被复制到拥有的客户端
    3.直接在节点上（或使用连接的变量）指定使用的力反馈效果,如需循环效果，勾选 Looping,还可为效果设置一个标签。通过标签可停止效果；如带有相同标签的效果已在播放，它将停止播放此效果并播放新的效果
    4. 通过 Get Player Controller 节点或保存的引用为玩家控制器设置一个引用。从引用的输出引脚引出连线，然后在快捷菜单中输入 Play Force Feedback，然后选择 Client Play Force Feedback。如在服务器上调用，力反馈将被复制到拥有的客户端。直接在节点上（或使用连接的变量）指定使用的力反馈效果。

- Add Child 节点用于在面板中将一个控件变为另一个控件的子/父控件，而 Add to Viewport 则将控件像新窗口一样添加到根窗口中。若要移除子控件，需要获取父控件并调用 RemoveChild

- 蓝图中首先执行的是事件节点，然后执行流程跟随白色执行引线从左至右进行，节点执行时将对输入引脚求值，从右到左反推数据引线，直至算出最终结果，并供应到节点

- 每个蓝图都具有一个“构造脚本”，和C++中的构造函数类似，当创建对象时会运行它，该脚本可以动态的基于多个因素来构建Actor实例，如：一个可以自动调整大小来填充建筑物间空隙的篱笆，从该角度来说，蓝图也是一个强大的预制系统

- 当创建一个蓝图类时，可以选择继承“原生”C++类，或者另一个蓝图类

- 影响是使用蓝图还是C++的因素:速度，表达式复杂度，大量计算，高频率操作，蓝图保留需要灵活性的部分

- 一个勾选Instance Editable为true的Vector变量可勾选Show3DWidget(在视图中可见该点)

- 一个物体若由多个组件构成，其他组件会跟随根组件移动

- BP作为类保存在包中

- HUD(Head Up Display)平视显示器，UMG支持与分辨率无关的，UI进行自动的缩放

- 蓝图不能触发按键事件时，通常加Enable Input即可解决

- Widget Interaction添加到角色蓝图时，注意控件坐标清零

- 一些事件节点，如 Left Mouse Button 在有2个时，只会执行一个，但选中该节点，取消勾选Details中 Consume Input,Override Parent Binding则可都执行

- 在对UI操作时，想不对世界做影响，除了设置游戏模式外，可以在需要的地方添加一个布尔变量来控制对UI操作时，是否可影响它

















